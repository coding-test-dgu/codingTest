'''

풀이 접근 방식
1. 각 테트로미노 5가지에 대해, 회전 상하좌우 회전, 대칭까지 해야함
- 테트로미노가 그래프 밖을 벗어나면 안됨.
2. 그래프 전체를 훑어야함.
-> 브루트 포스로 갈겨야 한다.

- 각 도형에 대해서 경우 나누기
- 각 도형에 대해 좌표가 범위를 벗어나면, 그 case는 종료하기

TODO

'''

import sys

info, *graph = [list(map(int, line.split())) for line in sys.stdin.readlines()]
row, col = info

# 딕셔내리로 5가지 도형에 대한 회전+플립 경우 19가지 선언
shapes = {1: [[(0,0),(1,0),(2,0),(3,0)], [(0,0),(0,1),(0,2),(0,3)]],
          2: [[(0,0),(1,0),(0,1),(1,1)]],
          3: [[(0,0),(1,0),(2,0),(2,1)], [(0,0),(0,1),(0,2),(1,0)],
              [(0,0),(0,1),(1,1),(2,1)], [(1,0),(1,1),(1,2),(0,2)],
              [(2,0),(2,1),(1,1),(0,1)], [(0,0),(1,0),(1,1),(1,2)],
              [(0,0),(0,1),(1,0),(2,0)], [(0,0),(0,1),(0,2),(1,2)]],
          4: [[(0,0),(1,0),(1,1),(2,1)], [(1,0),(1,1),(0,1),(0,2)],
              [(1,0),(1,1),(0,1),(2,0)], [(0,0),(0,1),(1,1),(1,2)]],
          5: [[(0,0),(0,1),(0,2),(1,1)], [(1,0),(1,1),(1,2),(0,1)],
              [(0,0),(1,0),(2,0),(1,1)], [(1,0),(0,1),(1,1),(2,1)]]}

def find_max(x, y):
    sum_max = 0
    for i in range(1,6): #
        for case in shapes[i]: # 19, 테트로미노 19가지 경우에 대해
            case_sum = 0
            cnt = 0
            for cx, cy in case: # 4, 각 경우의 좌표에 대해
                nx = cx + x
                ny = cy + y
                if 0<=nx<row and 0<=ny<col: # 만일 그래프 범위를 벗어나지 않으면
                    case_sum += graph[nx][ny]
                    cnt += 1
                else: # 벗어난다면
                    break

            if cnt == 4: # 만일 4개의 좌표가 다 유효한 좌표였다면,
                if sum_max < case_sum:
                    sum_max = case_sum

    return sum_max

answer = 0

for i in range(row): # 250000
    for j in range(col):
        result = find_max(i,j)

        if answer < result:
            answer = result

print(answer)